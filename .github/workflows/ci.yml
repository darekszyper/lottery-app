# .github/workflows/ci.yml
name: Deploy and Manage Infrastructure

on:
  workflow_dispatch:
    inputs:
      destroy:
        description: "If you want to destroy AWS DB and Heroku app type 'true'"
        required: false
        default: "false"

jobs:
  setup-rds:
    if: ${{ github.event.inputs.destroy != 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.0

      - name: Initialize Terraform
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: terraform init

      - name: Apply Terraform
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          terraform apply -auto-approve \
            -var="db_username=${{ secrets.DB_USERNAME }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"

      - name: Set Database Environment Variables
        id: db_vars
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          # Initialize with backend configuration
          terraform init \
            -backend-config="bucket=terraform-state-bucket-154335" \
            -backend-config="region=eu-central-1"

          # List all available outputs first
          terraform output

          # Try to get the output with error handling
          DB_URL=$(terraform output -raw db_url || echo "")

          # Check if DB_URL is empty
          if [ -z "$DB_URL" ]; then
            echo "Error: Could not retrieve database URL"
            exit 1
          fi

          # Use printf to ensure clean output
          printf "Database URL: %s\n" "$DB_URL"

          # Explicitly escape the URL when writing to environment
          printf "DB_URL=%q\n" "$DB_URL" >> $GITHUB_ENV
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV

  deploy-heroku:
    if: ${{ github.event.inputs.destroy != 'true' }}
    runs-on: ubuntu-latest
    needs: setup-rds
    steps:
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          java-version: 17
          distribution: temurin

      - name: Locate and make Maven wrapper executable
        run: |
          # Find the mvnw file
          MVNW_PATH=$(find . -name "mvnw" -type f | head -n 1)

          # Check if mvnw was found
          if [ -z "$MVNW_PATH" ]; then
            echo "Maven wrapper (mvnw) not found"
            exit 1
          fi

          # Make the found mvnw executable
          chmod +x "$MVNW_PATH"

          # Print the path for verification
          echo "Maven wrapper found at: $MVNW_PATH"

      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
          HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }}
          DATA_SOURCE_URL: ${{ env.DB_URL }}
          DATA_SOURCE_USERNAME: ${{ env.DB_USERNAME }}
          DATA_SOURCE_PASSWORD: ${{ env.DB_PASSWORD }}
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          RANDOM_API_KEY: ${{ secrets.RANDOM_API_KEY }}
          USER1_PASSWORD: ${{ secrets.USER1_PASSWORD }}
          USER2_PASSWORD: ${{ secrets.USER2_PASSWORD }}
        run: |
          # Find the mvnw file again to use
          MVNW_PATH=$(find . -name "mvnw" -type f | head -n 1)

          "$MVNW_PATH" clean install -DskipTests
          heroku deploy:jar target/*.jar --app $HEROKU_APP_NAME
#      - name: Checkout repo
#        uses: actions/checkout@v2
#
#      - name: Set up Java
#        uses: actions/setup-java@v3
#        with:
#          java-version: 17
#          distribution: temurin
#
#      - name: Deploy to Heroku
#        env:
#          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#          HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }}
#          DATA_SOURCE_URL: ${{ env.DB_URL }}
#          DATA_SOURCE_USERNAME: ${{ env.DB_USERNAME }}
#          DATA_SOURCE_PASSWORD: ${{ env.DB_PASSWORD }}
#          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
#          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
#          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
#          RANDOM_API_KEY: ${{ secrets.RANDOM_API_KEY }}
#          USER1_PASSWORD: ${{ secrets.USER1_PASSWORD }}
#          USER2_PASSWORD: ${{ secrets.USER2_PASSWORD }}
#        run: |
#          ./mvnw clean install -DskipTests
#          heroku deploy:jar target/*.jar --app $HEROKU_APP_NAME

  destroy:
    if: ${{ github.event.inputs.destroy == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.0

      - name: Destroy RDS
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          terraform init  # Ensure initialization before destroy
          terraform destroy -auto-approve \
            -var="db_username=${{ secrets.DB_USERNAME }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"

      - name: Delete Heroku App
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
          HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }}
        run: heroku apps:destroy --app $HEROKU_APP_NAME --confirm $HEROKU_APP_NAME